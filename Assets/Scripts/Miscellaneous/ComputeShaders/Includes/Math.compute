struct KeyFrameGPU
{
    float FrameTime;
    float FrameValue;
};

int3 ThreadDimensions;

int IndexByCoord(int x, int y, int z)
{
    return (z * ThreadDimensions.x * ThreadDimensions.y) + (y * ThreadDimensions.x) + x;
}

int IndexByCoord(int x, int y, int z, int3 dim)
{
    return (z * dim.x * dim.y) + (y * dim.x) + x;
}

int3 CoordByIndex(int idx) 
{
    int z = idx / (ThreadDimensions.x * ThreadDimensions.y);
    idx -= (z * ThreadDimensions.x * ThreadDimensions.y);
    int y = idx / ThreadDimensions.x;
    int x = idx % ThreadDimensions.x;
    return int3(x, y, z);
}

float Evaluate(float value, StructuredBuffer<KeyFrameGPU> keyframes, int keyframesCount)
{
	//If empty
	if (keyframesCount == 0) return 0;

	//If only one outcome exists
    if (keyframesCount == 1) return keyframes[0].FrameValue;

	//If below minimum
    if (value <= keyframes[0].FrameTime) return keyframes[0].FrameValue;

	//If above maximum
    if (value >= keyframes[keyframesCount - 1].FrameTime) return keyframes[keyframesCount - 1].FrameValue;

    for (int i = 0; i < keyframesCount; i++)
    {
        int nextIndex = i + 1;
        if (nextIndex < keyframesCount)
        {
            if (value >= keyframes[i].FrameTime && value < keyframes[nextIndex].FrameTime) return keyframes[i].FrameValue;
        }
    }
    return 0;
}