#include "/SimpleNoise.compute"

struct SurfaceBiomeGPU
{
    //Id
    int Id;
    //General
    float Persistance;
    //Surface layer
    float SurfaceHeight;
    float SurfaceFloor;
    //Additive layer
    float SurfaceAdditiveHeight;
    float SurfaceAdditiveHeightLimit;
    float SurfaceAdditiveOffset;
    //Subtractive
};

struct CaveBiomeGPU
{
    //Id
    int Id;
    //General
    float Persistance;
    //Cave layer
    float CaveThreshold;
    //Additive
    //Subtractive
};

struct RegionGPU
{
    float2 Coord;
    SurfaceBiomeGPU SurfaceBiome;
    CaveBiomeGPU CaveBiome;
};

float Perlin(float x, float y, float z, float scale, float presistance, float lacunarity, int octaves, StructuredBuffer<float3> mapOctaveOffsets)
{
	//Height value
    float total = 0;
    float frequency = 1;
    float amplitude = 1;
    float totalAmplitude = 0;

    for (int i = 0; i < octaves; i++)
    {
        float mapX = x / scale * frequency + mapOctaveOffsets[i].x;
        float mapY = y / scale * frequency + mapOctaveOffsets[i].y;
        float mapZ = z / scale * frequency + mapOctaveOffsets[i].z;

        total += cnoise(float3(mapX, mapY, mapZ)) * amplitude;
        totalAmplitude += amplitude;

        amplitude *= presistance;
        frequency *= lacunarity;
    }
    //total = abs(total);
    return total;
}

float Voronoi(float x, float y, int sites, StructuredBuffer<RegionGPU> mapRegions, out int outputRegionIndexes[3])
{
	//Get the 3 closest sites, brute-force method, need to create kdtrees
    float closestDistance = 999999;
    float secondClosestDistance = 999999;
    float thirdClosestDistance = 999999;
    float2 closestSiteCoord;
    float2 secondClosestSiteCoord;
    float2 thirdClosestSiteCoord;
    for (int i = 0; i < sites; i++)
    {
        float dist = distance(mapRegions[i].Coord, float2(x, y));

        if (dist < closestDistance)
        {
            thirdClosestDistance = secondClosestDistance;
            thirdClosestSiteCoord = secondClosestSiteCoord;
            outputRegionIndexes[2] = outputRegionIndexes[1];

            secondClosestDistance = closestDistance;
            secondClosestSiteCoord = closestSiteCoord;
            outputRegionIndexes[1] = outputRegionIndexes[0];

            closestDistance = dist;
            closestSiteCoord = mapRegions[i].Coord;
            outputRegionIndexes[0] = i;

        }

        if (dist < secondClosestDistance && dist > closestDistance)
        {
            thirdClosestDistance = secondClosestDistance;
            thirdClosestSiteCoord = secondClosestSiteCoord;
            outputRegionIndexes[2] = outputRegionIndexes[1];

            secondClosestDistance = dist;
            secondClosestSiteCoord = mapRegions[i].Coord;
            outputRegionIndexes[1] = i;
        }

        if (dist < thirdClosestDistance && dist > secondClosestDistance)
        {
            thirdClosestDistance = dist;
            thirdClosestSiteCoord = mapRegions[i].Coord;
            outputRegionIndexes[2] = i;
        }
    }

    return 1 - (closestDistance / secondClosestDistance);
}