struct SurfaceBiomeGPU
{
    //Id
    int Id;
    //General
    float Persistance;
    //Surface layer
    float SurfaceHeight;
    float SurfaceFloor;
    //Additive layer
    float SurfaceAdditiveHeight;
    float SurfaceAdditiveHeightLimit;
    float SurfaceAdditiveOffset;
    //Subtractive
};

struct CaveBiomeGPU
{
    //Id
    int Id;
    //General
    float Persistance;
    //Cave layer
    float CaveThreshold;
    //Additive
    //Subtractive
};

struct RegionGPU
{
    float2 Coord;
    SurfaceBiomeGPU SurfaceBiome;
    CaveBiomeGPU CaveBiome;
};

float Voronoi(float x, float y, int sites, StructuredBuffer<RegionGPU> mapRegions, out int outputRegionIndexes[3])
{
	//Get the 3 closest sites, brute-force method, need to create kdtrees
    float closestDistance = 999999;
    float secondClosestDistance = 999999;
    float thirdClosestDistance = 999999;
    float2 closestSiteCoord;
    float2 secondClosestSiteCoord;
    float2 thirdClosestSiteCoord;
    for (int i = 0; i < sites; i++)
    {
        float dist = distance(mapRegions[i].Coord, float2(x, y));

        if (dist < closestDistance)
        {
            thirdClosestDistance = secondClosestDistance;
            thirdClosestSiteCoord = secondClosestSiteCoord;
            outputRegionIndexes[2] = outputRegionIndexes[1];

            secondClosestDistance = closestDistance;
            secondClosestSiteCoord = closestSiteCoord;
            outputRegionIndexes[1] = outputRegionIndexes[0];

            closestDistance = dist;
            closestSiteCoord = mapRegions[i].Coord;
            outputRegionIndexes[0] = i;

        }

        if (dist < secondClosestDistance && dist > closestDistance)
        {
            thirdClosestDistance = secondClosestDistance;
            thirdClosestSiteCoord = secondClosestSiteCoord;
            outputRegionIndexes[2] = outputRegionIndexes[1];

            secondClosestDistance = dist;
            secondClosestSiteCoord = mapRegions[i].Coord;
            outputRegionIndexes[1] = i;
        }

        if (dist < thirdClosestDistance && dist > secondClosestDistance)
        {
            thirdClosestDistance = dist;
            thirdClosestSiteCoord = mapRegions[i].Coord;
            outputRegionIndexes[2] = i;
        }
    }

    return 1 - (closestDistance / secondClosestDistance);
}

float BlendDistance(float2 coord, RegionGPU closest, RegionGPU closestK)
{
    float closestDistance = distance(closest.Coord, coord);
    float closestKDistance = distance(closestK.Coord, coord);
    return 1 - (closestDistance / closestKDistance);
}

float BiomeBlendView(float voronoiBaseHeight, float2 coord, StructuredBuffer<RegionGPU> mapRegions, int regionIndexes[3], bool fullBlendView)
{
	float blendView = voronoiBaseHeight;
    //If the closest region's type is the same as the second closest region's type
    if (mapRegions[regionIndexes[0]].SurfaceBiome.Id == mapRegions[regionIndexes[1]].SurfaceBiome.Id)
    {
        blendView = 1;

        //If the closest region's type is not the same as the third closest region's type
        if (mapRegions[regionIndexes[0]].SurfaceBiome.Id != mapRegions[regionIndexes[2]].SurfaceBiome.Id)
        {
            if (fullBlendView) blendView = BlendDistance(coord, mapRegions[regionIndexes[0]], mapRegions[regionIndexes[2]]);
			else blendView = 0;
        }
    }
    return blendView;
}